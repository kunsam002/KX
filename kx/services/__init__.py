__author__ = 'kunsam002'
"""
services.py

@Author: Ogunmokun Olukunle


"""

import re
import json
from kx.core.utils import *
from kx.core.exceptions import ObjectNotFoundException
from unicodedata import normalize
from datetime import datetime, date, timedelta
from email.utils import formatdate
from calendar import timegm
from user_agents import parse
import requests
import os
import base64
import cStringIO
import string
import random
import phonenumbers
import hashlib
import math
from kx import logger
from pprint import pprint



class ServiceFactory(object):
    """
    Factory class for creating services. The service class will be bound to a model and returned as a class.
    This class can then be used or subclassed directly. The services generated by this class will contain
    specific methods for creating, retrieving, updating, deleting and querying data.
    """

    @classmethod
    def create_service(cls, klass, db):
        """
        :param cls: SQLAlchemy model class to be bound to service.

        This model will return
        """

        class BaseService:
            """ Generic class that contains all static/class methods required """

            def __init__(self):
                pass

            db = None
            query = None

            @classmethod
            def create(cls, ignored_args=None, **kwargs):
                """ Create the new model object and persist it. Execute possible pre/post method calls for audit and others """
                if not ignored_args:
                    ignored_args = ['id', 'date_created', 'last_updated', 'csrf_token']  # these attributes will be ignored

                obj = BaseService.model_class()
                data = clean_kwargs(ignored_args, kwargs)
                obj = populate_obj(obj, data)

                db.session.add(obj)
                try:
                    db.session.commit()
                    if hasattr(obj, "__search_class__"):
                        cls.index_object(obj)
                    return obj
                except:
                    db.session.rollback()
                    raise

            @classmethod
            def update(cls, obj_id, ignored_args=None, **kwargs):
                """ Update an existing model by obj_id and persist it. Execute """

                obj = BaseService.model_class.query.get(obj_id)

                if not obj:
                    raise ObjectNotFoundException(BaseService.model_class, obj_id)

                obj = db.session.merge(obj)
                if not ignored_args:
                    ignored_args = ["id", "date_created", "last_updated"]

                data = clean_kwargs(ignored_args, kwargs)
                obj = populate_obj(obj, data)
                db.session.add(obj)
                try:
                    db.session.commit()
                    return obj
                except:
                    db.session.rollback()
                    raise

            @classmethod
            def update_by_ids(cls, obj_ids, ignored_args=None, **kwargs):
                """ Execute bulk update on a group of objects selected by their ids """

                data = clean_kwargs(ignored_args, kwargs)
                data = remove_invalid_attributes(BaseService.model_class(), data)

                try:
                    res = cls.query.filter(cls.model_class.id.in_(obj_ids)).update(data, synchronize_session=False)
                    db.session.commit()
                    return res
                except Exception, e:
                    db.session.rollback()
                    raise

            @classmethod
            def get(cls, obj_id):
                """ Simple query method to get an object by obj_id """
                obj = cls.query.get(obj_id)

                if not obj:
                    raise ObjectNotFoundException(BaseService.model_class, obj_id)

                return obj

            @classmethod
            def delete(cls, obj_id):
                """ delete an object for the existing model by obj_id"""

                obj = cls.query.get(obj_id)
                obj = db.session.merge(obj)

                if not obj:
                    raise ObjectNotFoundException(BaseService.model_class, obj_id)

                db.session.delete(obj)
                try:
                    db.session.commit()
                    return True
                except:
                    db.session.rollback()
                    raise

            @classmethod
            def get_by_ids(cls, ids=None):
                """ Retrieve an array of objects specified by the ids """
                if not ids:
                    ids = []

                objects = cls.query.filter(cls.model_class.id.in_(ids))

                return objects

            @classmethod
            def delete_by_ids(cls, ids=None):
                """ Delete an array of objects specified by ids """
                if not ids:
                    ids = []
                for obj in cls.model_class.query.filter(cls.model_class.id.in_(ids)):
                    db.session.delete(obj)
                    try:
                        db.session.commit()
                    except:
                        db.session.rollback()
                        raise
                return True

        # Set the model class on the service
        BaseService.model_class = klass
        BaseService.db = db
        BaseService.query = klass.query

        return BaseService
